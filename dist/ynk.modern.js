import t from"lodash/isArray";import e from"lodash/isFunction";import r from"lodash/isString";export{default as topath}from"lodash/toPath";function n(t,e,r){if(t)return t;if(null==Error.captureStackTrace)throw new Error(e);const o=new Error(e);throw Error.captureStackTrace(o,r||n),o}const o=(t,e,r)=>(n(null!=t,e,r||o),t);var a=(t=0)=>new Promise(e=>setTimeout(e,t)),s=async(t=[],e,r)=>{t=Object.values(t);let n=r,o=0;for(let r of t)n=await e(n,r,o,t),++o;return n},i=(t,e=1)=>{const r=[];let n=0;return function(...o){n<e?function e(o){return++n,t(...o).finally(t=>{--n,r.length&&e(r.shift())})}(o):r.push(o)}},u={__proto__:null,doWhile:async function(t,e,...r){let n=!0;do{n=await t(...r),n&&await a(e)}while(n)},filter:(t,e)=>s(t,async(t,...r)=>(await e(...r)&&t.push(r[0]),t),[]),loop:async function(t,e,...r){for(;;)await t(...r),await a(e)},map:(t,e)=>s(t,async(t,...r)=>(t.push(await e(...r)),t),[]),reduce:s,series:i,Dispatch:t=>(e=(async t=>t))=>i(async function(...r){return t.set(await e(t.get(),...r))}),timeout:async(t,e,r="Request Timed Out")=>Promise.race([t,()=>a(e).then(t=>{throw new Error(r)})]),sleep:a};const c=[/node_modules/,/\internal\/process/],l=(t=c)=>(e="",r=0,n)=>e.split("\n").slice(r,n).filter(e=>t.reduce((t,r)=>t&&!r.test(e),!0)).join("\n");var f=(t,e)=>(...r)=>function t(e,r=0,n=[]){return 0==r?e(...n):(...o)=>t(e,r-1,[...n,...o])}(t,e,r),h=()=>{const t=new Set;function e(e){t.delete(e)}return{on:function(r){return n(r,"requires callback"),t.add(r),()=>e(r)},off:e,emit:function(...e){t.forEach(t=>setTimeout(t,0,...e))},listeners:t}};const d=require("lodash/get"),m=(t=16,e=0,r=0)=>()=>{let n=e.toString().padStart(t,"0");return++e,r&&(e%=r),n};function p(t={},e=[],r=(t=>t),n=0){if(0==e.length)return data;if(n==e.length-1)return r(t,e[n]),t;const o=e[n];return t[o]={...t[o]},p(t[o],e,r,n+1),t}var w=(t,e,r)=>p(t,e,(t,e)=>t[e]=r),g=(o={})=>{const a=new Map;function s(t){return a.delete(t)}return{on:function o(i,u=[]){if(n(e(i),"requires callback function",o),r(u))a.set(i,(c=u,(t,e)=>0==c.length?t==e:d(t,c)==d(e,c)));else if(t(u))a.set(i,((t=[])=>(e,r)=>0==t.length?e==r:t.every(t=>d(e,t)==d(r,t)))(u));else{if(!e(u))throw new Error("isEqual must be string, array of strings, array of arrays, or a function");a.set(i,u)}var c;return()=>s(i)},off:s,get:function(t,e){return null==t||0==t.length?o:d(o,t,e)},set:function(t){const e=o;o=t;for(let[r,n]of a.entries())n(e,t)||r(t)}}},y=(t,e,...r)=>{const n=setTimeout(t,e,...r);return()=>clearTimeout(n)},E=(t,e)=>Array.from({length:t},(t,r)=>e(r));function v(t={},e=[],r=(t=>t),n=0){if(0==e.length)return data;if(n==e.length-1)return r(t,e[n]),t;const o=e[n];return null==t[o]||(t[o]={...t[o]},v(t[o],e,r,n+1)),t}var S=(t,e,r)=>v(t,e,(t,e)=>delete t[e]);const T=t=>(e=(t=>t))=>(...r)=>t.set(e(t.get(),...r));export{l as Cleanstack,f as Curry,T as Dispatch,h as Events,m as IncreasingId,g as Store,n as assert,u as async,o as exists,d as get,w as set,y as timeout,E as times,p as touch,S as unset};
//# sourceMappingURL=ynk.modern.js.map
